# PEP 484: 类型提示

原 文 &nbsp; [PEP 484 -- Type Hints](https://www.python.org/dev/peps/pep-0484/)

<dl>
    <dt>作 者</dt>
    <dd>
        Guido van Rossum (guido@python.org) <br> 
        Jukka Lehtosalo (jukka.lehtosalo@iki.fi) <br>
        Lukasz Langa (lukasz@python.org)
    </dd>
</dl>

<!-- 翻 译 &nbsp; Wills Hua (wills.hua96@gmail.com) -->

状 态 &nbsp; 暂定提案

类 型 &nbsp; 标准类

<dl>
    <dt>发 布 历 史</dt>
    <dd>
        2015年1月16日 <br>
        2015年3月20日 <br>
        2015年4月17日 <br>
        2015年5月20日 <br>
        2015年5月22日 <br>
    </dt>
</dl>

<br>

## 目录

- [摘要](#chapter-1) <div id="content-1">
- [理由与目标](#chapter-2) <div id="content-2">
- [注解的含义](#chapter-3) <div id="content-3">
- [类型定义的语法](#chapter-4) <div id="content-4">
- [与函数注释其他用法的兼容性](#chapter-5) <div id="content-5">
- [类型注释](#chapter-6) <div id="content-6">
- [指定类型](#chapter-7) <div id="content-7">
- ['NewType' 工具函数](#chapter-8) <div id="content-8">
- [存根文件](#chapter-9) <div id="content-9">
- ['typing' 模块](#chapter-10) <div id="content-10">
- [Python 2.7 和跨版本代码的建议语法](#chapter-11) <div id="content-11">
- [未被接受的替代方案](#chapter-12) <div id="content-12">
- [PEP 开发过程](#chapter-13) <div id="content-13">
- [参考文献](#chapter-14) <div id="content-14">

<br>
<!-- <div class="page"/> -->

## <div id="chapter-1"> [一、摘要](#content-1) 

* [PEP 3107](https://www.python.org/dev/peps/pep-3107/) 已经引入了函数注解的语法, 但有意将语义保留为未定义. 目前第三方静态类型分析应用工具已经足够多了, 社区人员采用标准用语和标准库中的基线工具就将获益良多.

* 为了提供标准定义和工具, 本 PEP 引入了一个临时模块, 且列出一些不适用于注解情形的约定.

* 需要注意的是, 即使注解符合本规范, 本 PEP 依然明确不会妨碍注解的其他用法, 也不要求(或禁止)对注解的任意特殊处理. 正如 [PEP 333](https://www.python.org/dev/peps/pep-0333/) 对 Web 框架的约定, 这只是为了能够更好地合作.

* 例如这个简单函数, 其参数和返回值都在注解中给出了声明:
    ```Python
    def greeting(name: str) -> str:
        return "Hello " + name
    ```

  虽然在运行时通过常规的 '\_\_annotations\_\_' 属性可以访问到上述注解, 但运行时并不会进行类型检查. 本提案假定存在一个独立的脱机类型检查程序, 用户可以自愿对源代码运行此检查程序. 这种类型检查程序实质上就是一种非常强大的查错工具. (当然某些用户是可以在运行时采用类似的检查程序实现"契约式设计"或JIT优化, 但这些工具尚未完全成熟.)

* 本提案受到 [[mypy]](http://mypy-lang.org/) 的强烈启发. 如, "整数序列"类型可以写为 'Sequence[int]'. 方括号表示无需向语言添加新的语法. 上述示例用到了自定义类型 'Sequence', 是从纯 Python 模块 'typing' 中导入的. 通过实现元类(metaclass)中的 '\_\_getitem\_\_()' 方法, 'Sequence[int]' 表示法在运行时得以生效(但主要是对脱机类型检查程序有意义).

* 类型系统支持类型组合(Union)、范型类型(Generic type)和特殊类型 'Any', 'Any' 类型可与所有类型相容(即可以赋值给所有类型, 也可以从所有类型赋值). 'Any' 类型的特性取自渐进定型的理念. 渐进定型和全类型系统已在 [PEP 483](https://www.python.org/dev/peps/pep-0483/) 中有所解释.

* 在 [PEP 482](https://www.python.org/dev/peps/pep-0482/) 中, 还介绍了其他一些已借鉴或可比较的方案.

<br>
<!-- <div class="page"/> -->

## <div id="chapter-2"> [二、理由与目标](#content-2) 

* [PEP 3107](https://www.python.org/dev/peps/pep-3107/) 已加入了为函数定义中的各个部分添加注解的支持. 尽管没有为注解定义什么含义, 但已经隐隐有了一个目标, 即把注解用于类型提示 [[gvr-artima]](https://www.artima.com/weblogs/viewpost.jsp?thread=85551), 在 [PEP 3107](https://www.python.org/dev/peps/pep-3107/) 中这被列为第一个可能应用的场景.

* 本 PEP 旨在为类型注解提供一种标准语法, 让 Python 代码更加开放、更易于静态分析和重构, 提供一种潜在的运行时类型检查方案, 以及(或许在某些上下文中)能利用类型信息生成代码.

* 在这些目标中, 静态分析是最重要的. 包括了对 mypy 这类脱机类型检查程序的支持, 以及可供IDE使用的代码自动补全和重构的标准表示法.

### 非本文目标

* 虽然本提案的 'typing' 模块将包含一些用于运行时类型检查的功能模块, 特别是 'get_type_hints()' 函数, 但必须开发第三方程序包才能实现特定的运行时类型检查功能, 比如使用装饰器或元类. 

* 还有一点应强调的是, Python 仍将保持为一种动态类型语言, 并且按照惯例作者从未希望让类型提示成为强制类型.

<br>
<!-- <div class="page"/> -->

## <div id="chapter-3"> [三、注解的含义](#content-3) 

* 不带注解的函数都应被视为其类型可能是最通用的, 或应被任何类型检查器忽略的. 带有 '@no_type_check' 装饰器的函数应被视为不带注解的. 

* 建议但并不强求被检查函数的全部参数和返回类型都带有注解. 被检查函数的参数和返回类型的缺省注释为 'Any'. 一个例外是, 实例和类和方法的第一个参数. 如果未带注解, 则假定实例方法的第一个参数类型就是所在类的类型, 而类方法的第一个参数的类型则为所在对象类的类型. 例如在类 A 中, 实例方法的第一个参数的类型隐含为 A, 在类方法中, 第一个参数的精确类型无法用类型注解表示.

  (请注意, '\_\_init\_\_' 的返回类型应该用 '-> None' 进行注解. 原因比较微妙. 如果假定 '\_\_init\_\_' 缺省用 '-> None' 做为返回类型注解, 那么是否意味着无参数、不带注解的 '\_\_init\_\_' 方法还需要做类型检查? 与其任其模棱两可或引入异常, 还不如规定 '\_\_init\_\_' 应该带有返回类型注解, 默认表现与其他方法相同.)

* 类型检查程序应对函数主体和所给注解的一致性进行检查. 这些注解还可以用于检查其他被检函数对该函数的调用是否正确.

* 类型检查程序应该尽力推断出尽可能多的信息. 最低要求是能够处理内置装饰器 '@property', '@staticmenthod' 和 '@classmethod'.

<br>
<!-- <div class="page"/> -->

## <div id="chapter-4"> [四、类型定义的语法](#content-4) 

* 此处的语法充分利用了 [PEP 3107](https://www.python.org/dev/peps/pep-3107/) 风格的注解以及许多以下章节介绍的拓展. 类型提示的基本格式是把类名填入函数注解的位置: 
    ```Python
    def greeting(name: str) -> str:
        return "Hello" + name
    ```

  这段代码说明参数 'name' 的预期类型为 'str'. 类似地, 预期的函数返回类型为 'str'.

  其类型是特定参数类型子类型的表达式也被该参数接受.

### 1. 可接受的类型提示

* 类型提示可以是内置类(包含标准库或第三方拓展模块中定义的), 抽象基类, 'types' 模块中提供的类型和用户自定义类(包含标准可或第三方库中定义的).

* 虽然注解通常是类型提示的最佳格式, 但有时更适合用特殊注释或在单独发布的存根文件中表示. (示例见下文.)

* 注解必须是有效的表达式, 其计算过程不会使定义函数时引发异常. (向前引用见下文.)

* 注解应保持简洁, 否则静态分析工具可能无法对其进行解析. 例如动态计算得出的类型可能无法被理解. (此处要求有意模糊, 根据讨论结果可在本 PEP 的未来版本中加入某些包含和排除项.)

* 此外, 以下结构也可用作类型注解: 'None', 'Any', 'Union', 'Tuple', 'Callable', 用于构建由 'typing' 导出的类(如 'Sequence' 和 'Dict')的所有抽象基类 'ABC' 及其替代 'stand-in', 类型变量和类型别名.

* 'typing' 模块提供了所有用于支持以下章节中描述的功能而新引进的类型名(如 'Any' 和 'Union').

### 2. 使用 'None'

* 在类型提示中使用 'None' 时, 'None' 表达式被认为与 'type(None)' 等同.

### 3. 类型别名

* 类型别名(Type Aliases)是通过简单的变量赋值定义的:
    ```Python
    Url = str

    def retry(url: Url, retry_count: int) -> None: ...
    ```

  需要注意的是, 建议类型别名首字母大写, 因为这代表其是用户自定义类型, 而这种类型(用户自定义类)通常都使用这种方式拼写.

* 类型别名的复杂程度可以和注解中的类型提示一样, 类型注解可接受的内容在类型别名中都可接受.
    ```Python
    from typing import TypeVar, Iterable, Tuple

    T = TypeVar("T", int, float, complex)
    Vector = Iterable[Tuple[T, T]]

    def inproduct(v: Vector[T]) -> T:
        return sum(x*y for x, y in v)

    def dilate(v: Vector[T], scale: T) -> Vector[T]:
        return ((x * scale, y * scale) for x, y in v)

    vec = []  # type: Vector[float]
    ```

  这等同于:
    ```Python
    from typing import TypeVar, Iterable, Tuple

    T = TypeVar("T", int, float, complex)

    def inproduct(v: Iterable[Tuple[T, T]]) -> T:
        return sum(x*y for x, y in v)

    def dilate(v: Iterable[Tuple[T, T]], scale: T) -> Iterable[Tuple[T, T]]:
        return ((x * scale, y * scale) for x, y in v)

    vec = []  # type: Iterable[Tuple[T, T]]
    ```

### 4. Callable

* 框架需要返回特定签名的回调函数, 则可使用 'Callable[[Arg1Type, Arg2Type], ReturnType]' 形式作为类型提示. 如:
    ```Python
    from typing import Callable

    def feeder(get_next_item: Callable[[], str]) -> None:
        # Body

    def async_query(on_success: Callable[[int], None],
                    on_error: Callable[[int, Exception], None]) -> None:
        # Body
    ```

* 在声明返回 'Callable' 类型时也可以不用指定调用签名, 只需用省略号(3个句点)代替参数列表即可: 
    ```Python
    def partial(func: Callable[..., str], *args) -> Callable[..., str]:
        # Body
    ```

  需要注意的是省略号两侧不带括号. 在这种情况下, 回调函数的参数完全没有限制, 且同样可以使用带关键词的参数.

* 由于带关键字参数的回调函数并不常用, 所以当前不支持指定 'Callable' 类型的带关键字参数. 同理, 也不支持参数数量可变的回调函数签名.

* 因为 'type.Callable' 带有双重职能, 用于替代 'collections.abc.Callable', 所以 'isinstance(x, typing.Callable)' 的实现与 'isinstance(x, collections.abc.Callable)' 兼容, 但 'isinstance(x, typing.Callable[...])' 是不受支持的.

### 5. 范形

<br>
<!-- <div class="page"/> -->

## <div id="chapter-5"> [五、与函数注释其他用法的兼容性](#content-5) 

<br>
<!-- <div class="page"/> -->

## <div id="chapter-6"> [六、类型注释](#content-6) 

<br>
<!-- <div class="page"/> -->

## <div id="chapter-7"> [七、指定类型](#content-7) 

<br>
<!-- <div class="page"/> -->

## <div id="chapter-8"> [八、'NewType' 工具函数](#content-8) 

<br>
<!-- <div class="page"/> -->

## <div id="chapter-9"> [九、存根文件](#content-9) 

<br>
<!-- <div class="page"/> -->

## <div id="chapter-10"> [十、'typing' 模块](#content-10) 

<br>
<!-- <div class="page"/> -->

## <div id="chapter-11"> [十一、Python 2.7 和跨版本代码的建议语法](#content-11) 

<br>
<!-- <div class="page"/> -->

## <div id="chapter-12"> [十二、未被接受的替代方案](#content-12) 

<br>
<!-- <div class="page"/> -->

## <div id="chapter-13"> [十三、PEP 开发过程](#content-13) 

<br>
<!-- <div class="page"/> -->

## <div id="chapter-14"> [十四、参考文献](#content-14) 
